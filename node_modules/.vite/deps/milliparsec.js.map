{
  "version": 3,
  "sources": ["browser-external:node:buffer", "../../../../../../../../../../node_modules/milliparsec/dist/index.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"node:buffer\" has been externalized for browser compatibility. Cannot access \"node:buffer.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "import { Buffer } from 'node:buffer';\nexport const hasBody = (method) => ['POST', 'PUT', 'PATCH', 'DELETE'].includes(method);\nconst defaultPayloadLimit = 102400; // 100KB\nconst defaultErrorFn = (payloadLimit) => new Error(`Payload too large. Limit: ${payloadLimit} bytes`);\n// Main function\nexport const p = (fn, payloadLimit = defaultPayloadLimit, payloadLimitErrorFn = defaultErrorFn) => async (req, _res, next) => {\n    try {\n        const body = [];\n        for await (const chunk of req) {\n            const totalSize = body.reduce((total, buffer) => total + buffer.byteLength, 0);\n            if (totalSize > payloadLimit)\n                throw payloadLimitErrorFn(payloadLimit);\n            body.push(chunk);\n        }\n        return fn(Buffer.concat(body));\n    }\n    catch (e) {\n        next === null || next === void 0 ? void 0 : next(e);\n    }\n};\n/**\n * Parse payload with a custom function\n * @param fn\n */\nconst custom = (fn) => async (req, _res, next) => {\n    if (hasBody(req.method))\n        req.body = await p(fn)(req, _res, next);\n    next === null || next === void 0 ? void 0 : next();\n};\n/**\n * Parse JSON payload\n * @param options\n */\nconst json = ({ payloadLimit, payloadLimitErrorFn } = {}) => async (req, res, next) => {\n    if (hasBody(req.method)) {\n        req.body = await p((x) => {\n            const str = td.decode(x);\n            return str ? JSON.parse(str) : {};\n        }, payloadLimit, payloadLimitErrorFn)(req, res, next);\n    }\n    next === null || next === void 0 ? void 0 : next();\n};\n/**\n * Parse raw payload\n * @param options\n */\nconst raw = ({ payloadLimit, payloadLimitErrorFn } = {}) => async (req, _res, next) => {\n    if (hasBody(req.method)) {\n        req.body = await p((x) => x, payloadLimit, payloadLimitErrorFn)(req, _res, next);\n    }\n    next === null || next === void 0 ? void 0 : next();\n};\nconst td = new TextDecoder();\n/**\n * Stringify request payload\n * @param param0\n * @returns\n */\nconst text = ({ payloadLimit, payloadLimitErrorFn } = {}) => async (req, _res, next) => {\n    if (hasBody(req.method)) {\n        req.body = await p((x) => td.decode(x), payloadLimit, payloadLimitErrorFn)(req, _res, next);\n    }\n    next === null || next === void 0 ? void 0 : next();\n};\n/**\n * Parse urlencoded payload\n * @param options\n */\nconst urlencoded = ({ payloadLimit, payloadLimitErrorFn } = {}) => async (req, _res, next) => {\n    if (hasBody(req.method)) {\n        req.body = await p((x) => Object.fromEntries(new URLSearchParams(x.toString()).entries()), payloadLimit, payloadLimitErrorFn)(req, _res, next);\n    }\n    next === null || next === void 0 ? void 0 : next();\n};\nconst getBoundary = (contentType) => {\n    const match = /boundary=(.+);?/.exec(contentType);\n    return match ? `--${match[1]}` : null;\n};\nconst defaultFileSizeLimitErrorFn = (limit) => new Error(`File too large. Limit: ${limit} bytes`);\nconst defaultFileSizeLimit = 200 * 1024 * 1024;\nconst parseMultipart = (body, boundary, { fileCountLimit, fileSizeLimit = defaultFileSizeLimit, fileSizeLimitErrorFn = defaultFileSizeLimitErrorFn }) => {\n    const parts = body.split(new RegExp(`${boundary}(--)?`)).filter((part) => !!part && /content-disposition/i.test(part));\n    const parsedBody = {};\n    if (fileCountLimit && parts.length > fileCountLimit)\n        throw new Error(`Too many files. Limit: ${fileCountLimit}`);\n    // biome-ignore lint/complexity/noForEach: for...of fails\n    parts.forEach((part) => {\n        const [headers, ...lines] = part.split('\\r\\n').filter((part) => !!part);\n        const data = lines.join('\\r\\n').trim();\n        if (data.length > fileSizeLimit)\n            throw fileSizeLimitErrorFn(fileSizeLimit);\n        // Extract the name and filename from the headers\n        const name = /name=\"(.+?)\"/.exec(headers)[1];\n        const filename = /filename=\"(.+?)\"/.exec(headers);\n        if (filename) {\n            const contentTypeMatch = /Content-Type: (.+)/i.exec(data);\n            const fileContent = data.slice(contentTypeMatch[0].length + 2);\n            const file = new File([fileContent], filename[1], { type: contentTypeMatch[1] });\n            parsedBody[name] = parsedBody[name] ? [...parsedBody[name], file] : [file];\n            return;\n        }\n        parsedBody[name] = parsedBody[name] ? [...parsedBody[name], data] : [data];\n        return;\n    });\n    return parsedBody;\n};\n/**\n * Parse multipart form data (supports files as well)\n *\n * Does not restrict total payload size by default.\n * @param options\n */\nconst multipart = ({ payloadLimit = Number.POSITIVE_INFINITY, payloadLimitErrorFn, ...opts } = {}) => async (req, res, next) => {\n    if (hasBody(req.method)) {\n        req.body = await p((x) => {\n            const boundary = getBoundary(req.headers['content-type']);\n            if (boundary)\n                return parseMultipart(td.decode(x), boundary, opts);\n            return {};\n        }, payloadLimit, payloadLimitErrorFn)(req, res, next);\n    }\n    next === null || next === void 0 ? void 0 : next();\n};\nexport { custom, json, raw, text, urlencoded, multipart };\n"],
  "mappings": "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",
  "names": ["part"]
}
